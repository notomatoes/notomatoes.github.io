---
title: python datastruct
categories: [python,datastruct,leetcode] 
comments: true
---
# 字典树  
## 代码模板
```python
class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""
        self.is_word = False
    def insert(self, word):
        cur = self
        for w in word:
            cur = cur.children[w]
        cur.is_word = True
        cur.word = word
    def search(self, word):
        cur = self
        for w in word:
            if w not in cur.children:
                return False
            cur = cur.children[w]
        return cur.is_word
```  
## 相关题目
[LC212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)  
# 并查集
## 学习链接  
[**github√**](https://github.com/Liu821218213/LeetCode-Orust/blob/master/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93.md)  
[LC128. 最长连续序列题解](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/tu-jie-yu-dao-jiu-shen-jiu-bing-cha-ji-by-chun-men/)
## 代码模板  
```python
class UF:
    parent = {}  # parent = []
    cnt = 0
    def __init__(self, M):
        # 初始化 parent 和 cnt
        # self.parent = {i for i in range(n)}

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[x]
        return x
    def union(self, p, q):
        if self.connected(p, q): return
        self.parent[self.find(p)] = self.find(q)
        self.cnt -= 1
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```
优化
```python
class UF:
    parent = {}
    size = {}
    cnt = 0
    def __init__(self, M):
        # 初始化 parent，size 和 cnt
        # self.parent = {i for i in range(n)}

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[x]
            self.parent[x] = self.parent[self.parent[x]]  # 路径压缩：隔代压缩（基于循环）
        return x
        
    # def find(self, x):
    #     if x != self.parent[x]:
    #         self.parent[x] = self.find(self.parent[x])  # 路径压缩：完全压缩（基于递归）
    #     return self.parent[x]
    
    def union(self, p, q):
        if self.connected(p, q): return
        leader_p = self.find(p)  # 小的树挂到大的树上，使树尽量平衡，即按秩合并，基于size的优化方法
        leader_q = self.find(q)
        if self.size[leader_p] < self.size[leader_q]:
            self.parent[leader_p] = leader_q
        else:
            self.parent[leader_q] = leader_p
        self.cnt -= 1
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```
## 相关题目
[LC128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)