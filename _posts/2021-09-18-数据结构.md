---
title: python datastruct
categories: [python,datastruct,leetcode] 
comments: true
---  
# å­¦ä¹ é“¾æ¥ğŸ”—
[labuladong](https://github.com/labuladong/fucking-algorithm)
# å­—å…¸æ ‘  
## ä»£ç æ¨¡æ¿
```python
class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""
        self.is_word = False
    def insert(self, word):
        cur = self
        for w in word:
            cur = cur.children[w]
        cur.is_word = True
        cur.word = word
    def search(self, word):
        cur = self
        for w in word:
            if w not in cur.children:
                return False
            cur = cur.children[w]
        return cur.is_word
```  
## ç›¸å…³é¢˜ç›®
[LC212. å•è¯æœç´¢ II](https://leetcode-cn.com/problems/word-search-ii/)  
# å¹¶æŸ¥é›†
## å­¦ä¹ é“¾æ¥  
[**githubâˆš**](https://github.com/Liu821218213/LeetCode-Orust/blob/master/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93.md)  
[LC128. æœ€é•¿è¿ç»­åºåˆ—é¢˜è§£](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/tu-jie-yu-dao-jiu-shen-jiu-bing-cha-ji-by-chun-men/)
## ä»£ç æ¨¡æ¿  
```python
class UF:
    parent = {}  # parent = []
    cnt = 0
    def __init__(self, M):
        # åˆå§‹åŒ– parent å’Œ cnt
        # self.parent = {i for i in range(n)}

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[x]
        return x
    def union(self, p, q):
        if self.connected(p, q): return
        self.parent[self.find(p)] = self.find(q)
        self.cnt -= 1
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```
ä¼˜åŒ–
```python
class UF:
    parent = {}
    size = {}
    cnt = 0
    def __init__(self, M):
        # åˆå§‹åŒ– parentï¼Œsize å’Œ cnt
        # self.parent = {i for i in range(n)}

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[x]
            self.parent[x] = self.parent[self.parent[x]]  # è·¯å¾„å‹ç¼©ï¼šéš”ä»£å‹ç¼©ï¼ˆåŸºäºå¾ªç¯ï¼‰
        return x
        
    # def find(self, x):
    #     if x != self.parent[x]:
    #         self.parent[x] = self.find(self.parent[x])  # è·¯å¾„å‹ç¼©ï¼šå®Œå…¨å‹ç¼©ï¼ˆåŸºäºé€’å½’ï¼‰
    #     return self.parent[x]
    
    def union(self, p, q):
        if self.connected(p, q): return
        leader_p = self.find(p)  # å°çš„æ ‘æŒ‚åˆ°å¤§çš„æ ‘ä¸Šï¼Œä½¿æ ‘å°½é‡å¹³è¡¡ï¼Œå³æŒ‰ç§©åˆå¹¶ï¼ŒåŸºäºsizeçš„ä¼˜åŒ–æ–¹æ³•
        leader_q = self.find(q)
        if self.size[leader_p] < self.size[leader_q]:
            self.parent[leader_p] = leader_q
        else:
            self.parent[leader_q] = leader_p
        self.cnt -= 1
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```
## ç›¸å…³é¢˜ç›®
[LC128. æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/longest-consecutive-sequence/)  
# æ ‘çŠ¶æ•°ç»„
## å­¦ä¹ é“¾æ¥
[csdnæ ‘çŠ¶æ•°ç»„](https://blog.csdn.net/youngyangyang04/category_871105.html) 
[æ¯”è¾ƒè¯¦ç»†çš„](https://www.cnblogs.com/xenny/p/9739600.html)
## ä»£ç æ¨¡æ¿
```python
```
## ç›¸å…³é¢˜ç›®  