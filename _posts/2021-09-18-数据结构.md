---
title: python datastruct
categories: [python,datastruct,leetcode] 
comments: true
---  
# å­¦ä¹ é“¾æ¥ğŸ”—
[labuladong](https://github.com/labuladong/fucking-algorithm)
# å­—å…¸æ ‘  
## ä»£ç æ¨¡æ¿
```python
class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""
        self.is_word = False
    def insert(self, word):
        cur = self
        for w in word:
            cur = cur.children[w]
        cur.is_word = True
        cur.word = word
    def search(self, word):
        cur = self
        for w in word:
            if w not in cur.children:
                return False
            cur = cur.children[w]
        return cur.is_word
```  
## ç›¸å…³é¢˜ç›®
[LC212. å•è¯æœç´¢ II](https://leetcode-cn.com/problems/word-search-ii/)  
# å¹¶æŸ¥é›†
## å­¦ä¹ é“¾æ¥  
[**githubâˆš**](https://github.com/Liu821218213/LeetCode-Orust/blob/master/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93.md)  
[LC128. æœ€é•¿è¿ç»­åºåˆ—é¢˜è§£](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/tu-jie-yu-dao-jiu-shen-jiu-bing-cha-ji-by-chun-men/)
## ä»£ç æ¨¡æ¿  
```python
class UF:
    parent = {}  # parent = []
    cnt = 0
    def __init__(self, M):
        # åˆå§‹åŒ– parent å’Œ cnt
        # self.parent = {i for i in range(n)}

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[x]
        return x
    def union(self, p, q):
        if self.connected(p, q): return
        self.parent[self.find(p)] = self.find(q)
        self.cnt -= 1
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```
ä¼˜åŒ–
```python
class UF:
    parent = {}
    size = {}
    cnt = 0
    def __init__(self, M):
        # åˆå§‹åŒ– parentï¼Œsize å’Œ cnt
        # self.parent = {i for i in range(n)}

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[x]
            self.parent[x] = self.parent[self.parent[x]]  # è·¯å¾„å‹ç¼©ï¼šéš”ä»£å‹ç¼©ï¼ˆåŸºäºå¾ªç¯ï¼‰
        return x
        
    # def find(self, x):
    #     if x != self.parent[x]:
    #         self.parent[x] = self.find(self.parent[x])  # è·¯å¾„å‹ç¼©ï¼šå®Œå…¨å‹ç¼©ï¼ˆåŸºäºé€’å½’ï¼‰
    #     return self.parent[x]
    
    def union(self, p, q):
        if self.connected(p, q): return
        leader_p = self.find(p)  # å°çš„æ ‘æŒ‚åˆ°å¤§çš„æ ‘ä¸Šï¼Œä½¿æ ‘å°½é‡å¹³è¡¡ï¼Œå³æŒ‰ç§©åˆå¹¶ï¼ŒåŸºäºsizeçš„ä¼˜åŒ–æ–¹æ³•
        leader_q = self.find(q)
        if self.size[leader_p] < self.size[leader_q]:
            self.parent[leader_p] = leader_q
        else:
            self.parent[leader_q] = leader_p
        self.cnt -= 1
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```
## ç›¸å…³é¢˜ç›®
[LC128. æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/longest-consecutive-sequence/)  
# æ ‘çŠ¶æ•°ç»„
## å­¦ä¹ é“¾æ¥
[csdnæ ‘çŠ¶æ•°ç»„](https://blog.csdn.net/youngyangyang04/category_871105.html) 
[æ¯”è¾ƒè¯¦ç»†çš„](https://www.cnblogs.com/xenny/p/9739600.html)
## ä»£ç æ¨¡æ¿
```python

```
## ç›¸å…³é¢˜ç›®   
# å †ç²¾è®²   
## python heapqç›¸å…³æ“ä½œ
heapq çš„ä¸€äº›å¸¸ç”¨æ–¹æ³•ï¼š

1. heapify(list)ï¼Œå°†åˆ—è¡¨è½¬æ¢ä¸ºå°æ ¹å †çš„æ•°æ®ç»“æ„ã€‚

2. heappush(heap, x)ï¼Œå°† x åŠ å…¥å †ä¸­ã€‚

3. heappop(heap)ï¼Œä»å †ä¸­å¼¹å‡ºæœ€å°çš„å…ƒç´ ã€‚

4. heapreplace(heap, x)ï¼Œå¼¹å‡ºæœ€å°çš„å…ƒç´ ï¼Œå¹¶å°† x åŠ å…¥å †ä¸­ã€‚

5. heappushpop(heap, x)ï¼Œå…ˆæŠŠ x åŠ å…¥å †ä¸­ï¼Œå†å¼¹å‡ºæœ€å°çš„å…ƒç´ ã€‚

6. heapq.nlargest(n, heap)ï¼Œè¿”å› heap ä¸­å‰ n ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚

7. heapq.nsmallest(n, heap)ï¼Œè¿”å› heap ä¸­å‰ n ä¸ªæœ€å°çš„å…ƒç´ ã€‚  
## å¦‚ä½•è‡ªå®šä¹‰å †æ’åº?  
### é‡å†™__lt__æ–¹æ³• 
```python
import heapq

a = range(10)

class Node:
    def __init__(self, v):
        self.v = v

    def __lt__(self, other):
        # è‡ªå®šä¹‰ltä¾¿å¯å®ç°å¤§é¡¶å †
        return self.v > other.v


h = []
for i in a:
    heapq.heappush(h, Node(i))
ans = heapq.nsmallest(len(h), h)
for i in ans:
    print(i.v)
```
```python
a = [(1, 'asd', 2), (2, 'asd', 2), (1, 'asd', 3), (5, 'asd', 3), (1, 'fd', 3)]
# å¯¹äºaæƒ³è¦æŒ‰ç…§ç¬¬ä¸€ä¸ªæ•°ä»å¤§åˆ°å°ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä»å¤§åˆ°å°ï¼Œç¬¬ä¸‰ä¸ªæ•°å­—ä»å°åˆ°å¤§æ’åº
class Node:
    def __init__(self, v):
        self.a, self.b, self.c = v[0], v[1], v[2]

    def __lt__(self, other):
        if self.a != other.a:
            return self.a > other.a
        if self.b != other.b:
            return self.b > other.b
        return self.c < other.c
h = []
for i in a:
    heapq.heappush(h,Node(i))
ans = heapq.nsmallest(len(h),h)
for i in ans:
    print(i.a,i.b,i.c)
# 5 asd 3
# 2 asd 2
# 1 fd 3
# 1 asd 2
# 1 asd 3
```

### åˆ©ç”¨itemgetter
```python
from operator import itemgetter
import heapq

list1 = [1, 6, 4, 3, 9, 5]
list2 = ['12', 'a6', '4', 'c34', 'b9', '5']
list3 = [
    {'name': 'jim', 'age': 23, 'price': 500},
    {'name': 'mase', 'age': 23, 'price': 600},
    {'name': 'tom', 'age': 25, 'price': 2000},
    {'name': 'alice', 'age': 22, 'price': 300},
    {'name': 'rose', 'age': 21, 'price': 2400},
]

print(heapq.nlargest(len(list1), list1))
print(heapq.nlargest(len(list2), list2))
print(heapq.nlargest(len(list3), list3, key=itemgetter('age', 'price')))

print(heapq.nsmallest(len(list1), list1))
print(heapq.nsmallest(len(list2), list2))
print(heapq.nsmallest(len(list3), list3, key=itemgetter('age', 'price')))
